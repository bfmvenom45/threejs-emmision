<!doctype html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GLB + Unreal Bloom (three.js)</title>
  <style>
    html,body { height:100%; margin:0; background:#0a0a0a; }
    #app { width:100%; height:100%; }
    .panel {
      position: fixed; top: 12px; left: 12px; 
      background: rgba(20,20,20,0.7); color:#fff; padding:10px 12px; 
      font: 14px/1.2 system-ui, -apple-system, Segoe UI, Roboto; border-radius:12px;
      backdrop-filter: blur(6px);
    }
    .panel label { display:block; margin:8px 0 2px; opacity:.8 }
    .panel input { width:180px; }
  </style>
</head>
<body>
<div id="app"></div>

<div class="panel">
  <label>Bloom strength</label>
  <input id="strength" type="range" min="0" max="3" step="0.01" value="1.2">
  <label>Bloom threshold</label>
  <input id="threshold" type="range" min="0" max="1" step="0.001" value="0.8">
  <label>Bloom radius</label>
  <input id="radius" type="range" min="0" max="1" step="0.001" value="0.55">
  <label>Exposure</label>
  <input id="exposure" type="range" min="0" max="2" step="0.01" value="1.0">
  <label>Glow Intensity</label>
  <input id="glow" type="range" min="0" max="3" step="0.1" value="1.5">
  <label>Glow Color (Hue)</label>
  <input id="glowHue" type="range" min="0" max="360" step="1" value="200">
  
  <hr style="margin: 12px 0; border: 1px solid rgba(255,255,255,0.3);">
  <label style="display: flex; align-items: center; margin: 8px 0;">
    <input type="radio" name="bloomMode" value="simple" checked style="margin-right: 8px;"> 
    –ü—Ä–æ—Å—Ç–∏–π Bloom
  </label>
  <label style="display: flex; align-items: center; margin: 8px 0;">
    <input type="radio" name="bloomMode" value="selective" style="margin-right: 8px;"> 
    –°–µ–ª–µ–∫—Ç–∏–≤–Ω–∏–π Bloom (Three.js)
  </label>
  
  <hr style="margin: 12px 0; border: 1px solid rgba(255,255,255,0.3);">
  <button id="pulseToggle" style="width: 100%; padding: 8px; margin: 8px 0; background: rgba(0,170,255,0.3); color: white; border: 1px solid #00aaff; border-radius: 6px; cursor: pointer; font-size: 13px;">
    üí´ –£–≤—ñ–º–∫–Ω—É—Ç–∏ –ø—É–ª—å—Å–∞—Ü—ñ—é
  </button>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160/examples/jsm/"
  }
}
</script>

<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
  import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
  import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
  import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
  import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
  // ----- –±–∞–∑–æ–≤–∞ —Å—Ü–µ–Ω–∞
  const container = document.getElementById('app');
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0a0a0a);

  const camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
  camera.position.set(2.5, 1.8, 3.5);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  container.appendChild(renderer.domElement);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  // ----- –ó–º—ñ–Ω–Ω—ñ –¥–ª—è —Ä—ñ–∑–Ω–∏—Ö —Ä–µ–∂–∏–º—ñ–≤ bloom -----
  let bloomMode = 'simple'; // 'simple' –∞–±–æ 'selective'
  let currentModel = null;
  let innerLight, innerLight2;
  
  // –ê–Ω—ñ–º–∞—Ü—ñ—è –ø—É–ª—å—Å–∞—Ü—ñ—ó
  let pulseEnabled = false;
  let pulseTime = 0;
  const pulseSpeed = 2.0; // —à–≤–∏–¥–∫—ñ—Å—Ç—å –ø—É–ª—å—Å–∞—Ü—ñ—ó
  const pulseIntensity = 0.5; // —ñ–Ω—Ç–µ–Ω—Å–∏–≤–Ω—ñ—Å—Ç—å –ø—É–ª—å—Å–∞—Ü—ñ—ó
  let baseLightIntensity = 3.0; // –±–∞–∑–æ–≤–∞ —è—Å–∫—Ä–∞–≤—ñ—Å—Ç—å
  let baseGlowIntensity = 1.5; // –±–∞–∑–æ–≤–∞ —è—Å–∫—Ä–∞–≤—ñ—Å—Ç—å glow
  
  // –î–ª—è –ø—Ä–æ—Å—Ç–æ–≥–æ —Ä–µ–∂–∏–º—É
  let simpleComposer;
  
  // –î–ª—è —Å–µ–ª–µ–∫—Ç–∏–≤–Ω–æ–≥–æ —Ä–µ–∂–∏–º—É
  const ENTIRE_SCENE = 0, BLOOM_SCENE = 1;
  let bloomComposer, finalComposer, finalPass;
  const bloomLayer = new THREE.Layers();
  bloomLayer.set(BLOOM_SCENE);
  const darkMaterial = new THREE.MeshBasicMaterial({ color: 'black' });
  const materialsCache = [];

  // ----- –§—É–Ω–∫—Ü—ñ—ó –¥–ª—è —Ä–æ–±–æ—Ç–∏ –∑ bloom -----
  function initSimpleBloom() {
    const renderPass = new RenderPass(scene, camera);
    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(container.clientWidth, container.clientHeight),
      1.2, 0.55, 0.8
    );
    
    simpleComposer = new EffectComposer(renderer);
    simpleComposer.addPass(renderPass);
    simpleComposer.addPass(bloomPass);
    
    return { renderPass, bloomPass };
  }
  
  function initSelectiveBloom() {
    const renderPass = new RenderPass(scene, camera);
    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(container.clientWidth, container.clientHeight),
      1.5, 0.4, 0.85
    );
    
    bloomComposer = new EffectComposer(renderer);
    bloomComposer.renderToScreen = false;
    bloomComposer.addPass(renderPass);
    bloomComposer.addPass(bloomPass);
    
    finalPass = new ShaderPass(
      new THREE.ShaderMaterial({
        uniforms: {
          baseTexture: { value: null },
          bloomTexture: { value: bloomComposer.renderTarget2.texture }
        },
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
          }
        `,
        fragmentShader: `
          uniform sampler2D baseTexture;
          uniform sampler2D bloomTexture;
          varying vec2 vUv;
          void main() {
            gl_FragColor = ( texture2D( baseTexture, vUv ) + vec4( 1.0 ) * texture2D( bloomTexture, vUv ) );
          }
        `,
        defines: {}
      }), 'baseTexture'
    );
    finalPass.needsSwap = true;
    
    finalComposer = new EffectComposer(renderer);
    finalComposer.addPass(renderPass);
    finalComposer.addPass(finalPass);
    
    return { renderPass, bloomPass };
  }
  
  function renderBloom(mask) {
    if (mask === true) {
      scene.traverse(darkenNonBloomed);
      bloomComposer.render();
      scene.traverse(restoreMaterial);
    } else {
      camera.layers.set(BLOOM_SCENE);
      bloomComposer.render();
      camera.layers.set(ENTIRE_SCENE);
    }
  }
  
  function darkenNonBloomed(obj) {
    if (obj.isMesh && bloomLayer.test(obj.layers) === false) {
      materialsCache[obj.uuid] = obj.material;
      obj.material = darkMaterial;
    }
  }
  
  function restoreMaterial(obj) {
    if (materialsCache[obj.uuid]) {
      obj.material = materialsCache[obj.uuid];
      delete materialsCache[obj.uuid];
    }
  }
  
  // –§—É–Ω–∫—Ü—ñ—è –ø—É–ª—å—Å–∞—Ü—ñ—ó —Å–≤—ñ—Ç–ª–∞
  function updatePulse(deltaTime) {
    if (!pulseEnabled) return;
    
    pulseTime += deltaTime * pulseSpeed;
    const pulse = Math.sin(pulseTime) * pulseIntensity + 1.0; // –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç –≤—ñ–¥ 0.5 –¥–æ 1.5
    
    // –ü—É–ª—å—Å–∞—Ü—ñ—è –≤–Ω—É—Ç—Ä—ñ—à–Ω—å–æ–≥–æ —Å–≤—ñ—Ç–ª–∞ (—Ç—ñ–ª—å–∫–∏ –¥–ª—è –ø—Ä–æ—Å—Ç–æ–≥–æ —Ä–µ–∂–∏–º—É)
    if (bloomMode === 'simple' && innerLight && innerLight2) {
      innerLight.intensity = baseLightIntensity * pulse;
      innerLight2.intensity = (baseLightIntensity * 0.7) * pulse;
    }
    
    // –ü—É–ª—å—Å–∞—Ü—ñ—è –µ–º—ñ—Å–∏–≤–Ω–∏—Ö –º–∞—Ç–µ—Ä—ñ–∞–ª—ñ–≤
    if (currentModel) {
      const currentGlowIntensity = baseGlowIntensity * pulse;
      
      currentModel.traverse((child) => {
        if (child.isMesh && child.material && child.userData.glowApplied) {
          if (child.material.emissive) {
            child.material.emissiveIntensity = currentGlowIntensity;
          }
        }
      });
    }
  }
  
  function togglePulse() {
    pulseEnabled = !pulseEnabled;
    const button = document.getElementById('pulseToggle');
    
    if (pulseEnabled) {
      button.textContent = 'üí´ –í–∏–º–∫–Ω—É—Ç–∏ –ø—É–ª—å—Å–∞—Ü—ñ—é';
      button.style.background = 'rgba(255,100,100,0.3)';
      button.style.borderColor = '#ff6464';
      pulseTime = 0; // —Å–∫–∏–¥–∞—î–º–æ —á–∞—Å
    } else {
      button.textContent = 'üí´ –£–≤—ñ–º–∫–Ω—É—Ç–∏ –ø—É–ª—å—Å–∞—Ü—ñ—é';
      button.style.background = 'rgba(0,170,255,0.3)';
      button.style.borderColor = '#00aaff';
      
      // –ü–æ–≤–µ—Ä—Ç–∞—î–º–æ –Ω–æ—Ä–º–∞–ª—å–Ω—ñ –∑–Ω–∞—á–µ–Ω–Ω—è
      if (bloomMode === 'simple' && innerLight && innerLight2) {
        innerLight.intensity = baseLightIntensity;
        innerLight2.intensity = baseLightIntensity * 0.7;
      }
      
      if (currentModel) {
        currentModel.traverse((child) => {
          if (child.isMesh && child.material && child.userData.glowApplied) {
            if (child.material.emissive) {
              child.material.emissiveIntensity = baseGlowIntensity;
            }
          }
        });
      }
    }
  }

  // —Å–≤—ñ—Ç–ª–æ
// const key = new THREE.DirectionalLight(0xffffff, 1.0);
// key.position.set(3, 5, 2);
// scene.add(key, new THREE.AmbientLight(0xffffff, 0.25));

// –ó–∞–ª–∏—à–∞—î–º–æ —Ç—ñ–ª—å–∫–∏ –º—ñ–Ω—ñ–º–∞–ª—å–Ω–µ ambient —Å–≤—ñ—Ç–ª–æ
scene.add(new THREE.AmbientLight(0x404040, 0.1)); // —Ç–µ–º–Ω–µ ambient —Å–≤—ñ—Ç–ª–æ

  // ----- –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è bloom —Ä–µ–∂–∏–º—ñ–≤ -----
  const simpleBloom = initSimpleBloom();
  const selectiveBloom = initSelectiveBloom();
  
  // –ü–æ—á–∏–Ω–∞—î–º–æ –∑ –ø—Ä–æ—Å—Ç–æ–≥–æ —Ä–µ–∂–∏–º—É
  let currentBloomPass = simpleBloom.bloomPass;
  initLights();

  // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è –ø—Ä–æ—Å—Ç–æ–≥–æ –æ–±'—î–∫—Ç–∞ —è–∫ fallback
  function createFallbackObject() {
    console.log('–°—Ç–≤–æ—Ä—é—é —Ä–µ–∑–µ—Ä–≤–Ω–∏–π –æ–±\'—î–∫—Ç...');
    const geometry = new THREE.BoxGeometry(1, 1, 1);
    const material = new THREE.MeshStandardMaterial({ 
      color: 0x2244aa,
      emissive: 0x00aaff,
      emissiveIntensity: 1.5,
      transparent: true,
      opacity: 0.9
    });
    const cube = new THREE.Mesh(geometry, material);
    
    // –ü–æ–∑–Ω–∞—á–∞—î–º–æ, —â–æ –µ—Ñ–µ–∫—Ç –∑–∞—Å—Ç–æ—Å–æ–≤–∞–Ω–∏–π
    cube.userData.glowApplied = true;
    
    // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –ø–æ—Å–∏–ª–∞–Ω–Ω—è –¥–ª—è –∫–æ–Ω—Ç—Ä–æ–ª—ñ–≤
    currentModel = cube;
    
    scene.add(cube);
    console.log('–†–µ–∑–µ—Ä–≤–Ω–∏–π –∫—É–± –∑ –µ—Ñ–µ–∫—Ç–æ–º —Å–≤—ñ—Ç—ñ–Ω–Ω—è –¥–æ–¥–∞–Ω–æ –¥–æ —Å—Ü–µ–Ω–∏');
  }

  // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è –µ—Ñ–µ–∫—Ç—É –≤–Ω—É—Ç—Ä—ñ—à–Ω—å–æ–≥–æ —Å–≤—ñ—Ç—ñ–Ω–Ω—è
  function addInnerGlow(object) {
    // –ó–±–∏—Ä–∞—î–º–æ –≤—Å—ñ mesh –æ–±'—î–∫—Ç–∏ —Å–ø–æ—á–∞—Ç–∫—É, —â–æ–± —É–Ω–∏–∫–Ω—É—Ç–∏ —Ä–µ–∫—É—Ä—Å—ñ—ó
    const meshes = [];
    object.traverse((child) => {
      if (child.isMesh && child.material && !child.userData.isOutline) {
        meshes.push(child);
      }
    });
    
    // –¢–µ–ø–µ—Ä –æ–±—Ä–æ–±–ª—è—î–º–æ –∫–æ–∂–µ–Ω mesh –æ–∫—Ä–µ–º–æ
    meshes.forEach((child) => {
      try {
        // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ –≤–∂–µ –æ–±—Ä–æ–±–∏–ª–∏ —Ü–µ–π mesh
        if (child.userData.glowApplied) return;
        
        // –ü–æ–∑–Ω–∞—á–∞—î–º–æ, —â–æ –æ–±—Ä–æ–±–∏–ª–∏ —Ü–µ–π mesh
        child.userData.glowApplied = true;
        
        // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω–∏–π –º–∞—Ç–µ—Ä—ñ–∞–ª –∞–±–æ —Å—Ç–≤–æ—Ä—é—î–º–æ –Ω–æ–≤–∏–π
        let glowMaterial;
        if (child.material.isArray) {
          // –Ø–∫—â–æ –º–∞—Ç–µ—Ä—ñ–∞–ª - –º–∞—Å–∏–≤, –æ–±—Ä–æ–±–ª—è—î–º–æ –ø–µ—Ä—à–∏–π
          glowMaterial = child.material[0].clone();
        } else {
          glowMaterial = child.material.clone();
        }
        
        // –ù–∞–ª–∞—à—Ç–æ–≤—É—î–º–æ –µ–º—ñ—Å—ñ—é –¥–ª—è –≤–Ω—É—Ç—Ä—ñ—à–Ω—å–æ–≥–æ —Å–≤—ñ—Ç—ñ–Ω–Ω—è
        glowMaterial.emissive = new THREE.Color(0x00aaff); // –ë–ª–∞–∫–∏—Ç–Ω–µ —Å–≤—ñ—Ç—ñ–Ω–Ω—è
        glowMaterial.emissiveIntensity = 1.5;
        
        // –î–æ–¥–∞—î–º–æ –ø—Ä–æ–∑–æ—Ä—ñ—Å—Ç—å –¥–ª—è –µ—Ñ–µ–∫—Ç—É
        glowMaterial.transparent = true;
        glowMaterial.opacity = 0.9;
        
        // –ù–∞–ª–∞—à—Ç–æ–≤—É—î–º–æ –æ—Å–Ω–æ–≤–Ω–∏–π –∫–æ–ª—ñ—Ä –∑ –ª–µ–≥–∫–∏–º –≤—ñ–¥—Ç—ñ–Ω–∫–æ–º
        glowMaterial.color = new THREE.Color(0x2244aa);
        
        child.material = glowMaterial;
        
        // –°—Ç–≤–æ—Ä—é—î–º–æ –¥–æ–¥–∞—Ç–∫–æ–≤–∏–π mesh –¥–ª—è –∫–æ–Ω—Ç—É—Ä–Ω–æ–≥–æ —Å–≤—ñ—Ç—ñ–Ω–Ω—è
        if (child.geometry) {
          const outlineGeometry = child.geometry.clone();
          const outlineMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ddff,
            transparent: true,
            opacity: 0.3,
            side: THREE.BackSide // –ü–æ–∫–∞–∑—É—î–º–æ —Ç—ñ–ª—å–∫–∏ –∑–≤–æ—Ä–æ—Ç–Ω—é —Å—Ç–æ—Ä–æ–Ω—É
          });
          
          const outlineMesh = new THREE.Mesh(outlineGeometry, outlineMaterial);
          outlineMesh.scale.multiplyScalar(1.05); // –¢—Ä–æ—Ö–∏ –∑–±—ñ–ª—å—à—É—î–º–æ –¥–ª—è –∫–æ–Ω—Ç—É—Ä—É
          
          // –ü–æ–∑–Ω–∞—á–∞—î–º–æ —è–∫ outline, —â–æ–± —É–Ω–∏–∫–Ω—É—Ç–∏ –ø–æ–≤—Ç–æ—Ä–Ω–æ—ó –æ–±—Ä–æ–±–∫–∏
          outlineMesh.userData.isOutline = true;
          
          // –î–æ–¥–∞—î–º–æ –∫–æ–Ω—Ç—É—Ä —è–∫ –¥–æ—á—ñ—Ä–Ω—ñ–π –æ–±'—î–∫—Ç
          child.add(outlineMesh);
        }
      } catch (error) {
        console.warn('–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–∞—Å—Ç–æ—Å—É–≤–∞–Ω–Ω—ñ –µ—Ñ–µ–∫—Ç—É —Å–≤—ñ—Ç—ñ–Ω–Ω—è –¥–æ mesh:', error);
      }
    });
  }

  // –ö–æ–º–ø–æ–∑–∏—Ç–æ—Ä–∏ —Å—Ç–≤–æ—Ä—é—é—Ç—å—Å—è –≤ —Ñ—É–Ω–∫—Ü—ñ—è—Ö initSimpleBloom() —Ç–∞ initSelectiveBloom()

    // ----- –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è GLB
  const loader = new GLTFLoader();
  
  console.log('–°–ø—Ä–æ–±–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –º–æ–¥–µ–ª—ñ...');
  
  // –°–ø–æ—á–∞—Ç–∫—É —Å–ø—Ä–æ–±—É—î–º–æ –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –º–æ–¥–µ–ª—å
  loader.load(
    './Susanna1.glb',
    // onLoad
    (gltf) => {
      console.log('–ú–æ–¥–µ–ª—å —É—Å–ø—ñ—à–Ω–æ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–∞:', gltf);
      const root = gltf.scene;
      scene.add(root);

      // –ù–æ—Ä–º–∞–ª—ñ–∑—É—î–º–æ –º–∞—Å—à—Ç–∞–±/–ø–æ–∑–∏—Ü—ñ—é (—â–æ–± –º–æ–¥–µ–ª—å –±—É–ª–∞ –≤ –∫–∞–¥—Ä—ñ)
      root.traverse(o => {
        if (o.isMesh) {
          o.castShadow = o.receiveShadow = true;
          // –í–ê–ñ–õ–ò–í–û: –¥–ª—è –µ–º—ñ—Å—ñ—ó —É glTF –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ emmisive / emissiveIntensity
          if (o.material && o.material.emissive) {
            // —è–∫—â–æ —Ö–æ—á–µ—à —Ç—Ä–æ—Ö–∏ –ø—ñ–¥—Å–≤—ñ—Ç–∏—Ç–∏ –µ–º—ñ—Å—ñ—é
            o.material.emissiveIntensity = Math.max(o.material.emissiveIntensity ?? 1.0, 1.2);
            o.material.needsUpdate = true;
          }
        }
      });

      // —Ü–µ–Ω—Ç—Ä–∏—Ä—É—î–º–æ –º–æ–¥–µ–ª—å —É —Å—Ü–µ–Ω—ñ
      const box = new THREE.Box3().setFromObject(root);
      const size = box.getSize(new THREE.Vector3()).length();
      const center = box.getCenter(new THREE.Vector3());
      root.position.sub(center);               // –ø–µ—Ä–µ–º—ñ—Å—Ç–∏–ª–∏ —Ü–µ–Ω—Ç—Ä –º–æ–¥–µ–ª—ñ –≤ (0,0,0)
      const scale = 2.0 / size;                // –Ω–æ—Ä–º–∞–ª—å–Ω–∏–π –º–∞—Å—à—Ç–∞–± —É –∫–∞–¥—Ä—ñ
      root.scale.setScalar(scale);
      
      // –ó–∞—Å—Ç–æ—Å–æ–≤—É—î–º–æ –µ—Ñ–µ–∫—Ç –≤–Ω—É—Ç—Ä—ñ—à–Ω—å–æ–≥–æ —Å–≤—ñ—Ç—ñ–Ω–Ω—è
      addInnerGlow(root);
      
      // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –ø–æ—Å–∏–ª–∞–Ω–Ω—è –¥–ª—è –∫–æ–Ω—Ç—Ä–æ–ª—ñ–≤
      currentModel = root;
      
      console.log('–ú–æ–¥–µ–ª—å –∑ –µ—Ñ–µ–∫—Ç–æ–º —Å–≤—ñ—Ç—ñ–Ω–Ω—è –¥–æ–¥–∞–Ω–∞ –¥–æ —Å—Ü–µ–Ω–∏. –†–æ–∑–º—ñ—Ä:', size, '–ú–∞—Å—à—Ç–∞–±:', scale);
    },
    // onProgress
    (progress) => {
      console.log('–ü—Ä–æ–≥—Ä–µ—Å –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è:', (progress.loaded / progress.total * 100) + '%');
    },
    // onError
    (error) => {
      console.error('–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –º–æ–¥–µ–ª—ñ:', error);
      console.log('–°–ø—Ä–æ–±–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–æ—ó –º–æ–¥–µ–ª—ñ...');
      
      // –°–ø—Ä–æ–±—É—î–º–æ –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ —ñ–Ω—à—É –º–æ–¥–µ–ª—å
      loader.load('./Susanna.glb', (gltf) => {
        console.log('–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–∞ –º–æ–¥–µ–ª—å –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–∞');
        const root = gltf.scene;
        scene.add(root);
        
        // –¢–æ–π —Å–∞–º–∏–π –∫–æ–¥ –Ω–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—ó
        root.traverse(o => {
          if (o.isMesh) {
            o.castShadow = o.receiveShadow = true;
            if (o.material && o.material.emissive) {
              o.material.emissiveIntensity = Math.max(o.material.emissiveIntensity ?? 1.0, 1.2);
              o.material.needsUpdate = true;
            }
          }
        });
        
        const box = new THREE.Box3().setFromObject(root);
        const size = box.getSize(new THREE.Vector3()).length();
        const center = box.getCenter(new THREE.Vector3());
        root.position.sub(center);
        const scale = 2.0 / size;
        root.scale.setScalar(scale);
        
        // –ó–∞—Å—Ç–æ—Å–æ–≤—É—î–º–æ –µ—Ñ–µ–∫—Ç –≤–Ω—É—Ç—Ä—ñ—à–Ω—å–æ–≥–æ —Å–≤—ñ—Ç—ñ–Ω–Ω—è
        addInnerGlow(root);
        
        // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –ø–æ—Å–∏–ª–∞–Ω–Ω—è –¥–ª—è –∫–æ–Ω—Ç—Ä–æ–ª—ñ–≤
        currentModel = root;
      }, undefined, (err) => {
        console.error('–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–æ—ó –º–æ–¥–µ–ª—ñ:', err);
        // –°—Ç–≤–æ—Ä–∏–º–æ –ø—Ä–æ—Å—Ç–∏–π –∫—É–± —è–∫ fallback
        createFallbackObject();
      });
    }
  );

  // ----- UI-–ø–æ–≤–∑—É–Ω–∫–∏
  const strengthEl = document.getElementById('strength');
  const thresholdEl = document.getElementById('threshold');
  const radiusEl = document.getElementById('radius');
  const exposureEl = document.getElementById('exposure');
  const glowEl = document.getElementById('glow');
  const glowHueEl = document.getElementById('glowHue');

  const sync = () => {
    // –û–Ω–æ–≤–ª—é—î–º–æ bloom –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ –¥–ª—è –ø–æ—Ç–æ—á–Ω–æ–≥–æ —Ä–µ–∂–∏–º—É
    currentBloomPass.strength  = parseFloat(strengthEl.value);
    currentBloomPass.threshold = parseFloat(thresholdEl.value);
    currentBloomPass.radius    = parseFloat(radiusEl.value);
    renderer.toneMappingExposure = parseFloat(exposureEl.value);
    
    // –û–Ω–æ–≤–ª—é—î–º–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ —Å–≤—ñ—Ç—ñ–Ω–Ω—è –º–æ–¥–µ–ª—ñ
    if (currentModel) {
      const glowIntensity = parseFloat(glowEl.value);
      baseGlowIntensity = glowIntensity; // –∑–±–µ—Ä—ñ–≥–∞—î–º–æ –±–∞–∑–æ–≤–µ –∑–Ω–∞—á–µ–Ω–Ω—è
      const hue = parseFloat(glowHueEl.value) / 360;
      const glowColor = new THREE.Color().setHSL(hue, 0.8, 0.5);
      
      // –û–Ω–æ–≤–ª—é—î–º–æ –≤–Ω—É—Ç—Ä—ñ—à–Ω—î —Å–≤—ñ—Ç–ª–æ
      if (innerLight && innerLight2) {
        baseLightIntensity = glowIntensity * 2.0; // –∑–±–µ—Ä—ñ–≥–∞—î–º–æ –±–∞–∑–æ–≤–µ –∑–Ω–∞—á–µ–Ω–Ω—è
        innerLight.color.copy(glowColor);
        innerLight2.color.copy(glowColor).multiplyScalar(0.8);
        
        // –û–Ω–æ–≤–ª—é—î–º–æ —ñ–Ω—Ç–µ–Ω—Å–∏–≤–Ω—ñ—Å—Ç—å —Ç—ñ–ª—å–∫–∏ —è–∫—â–æ –Ω–µ –ø—É–ª—å—Å–∞—Ü—ñ—è
        if (!pulseEnabled) {
          innerLight.intensity = baseLightIntensity;
          innerLight2.intensity = baseLightIntensity * 0.7;
        }
      }
      
      currentModel.traverse((child) => {
        if (child.isMesh && child.material && child.userData.glowApplied) {
          // –û–Ω–æ–≤–ª—é—î–º–æ –µ–º—ñ—Å—ñ—é –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –º–∞—Ç–µ—Ä—ñ–∞–ª—É
          if (child.material.emissive) {
            child.material.emissive.copy(glowColor);
            // –û–Ω–æ–≤–ª—é—î–º–æ —ñ–Ω—Ç–µ–Ω—Å–∏–≤–Ω—ñ—Å—Ç—å —Ç—ñ–ª—å–∫–∏ —è–∫—â–æ –Ω–µ –ø—É–ª—å—Å–∞—Ü—ñ—è
            if (!pulseEnabled) {
              child.material.emissiveIntensity = glowIntensity;
            }
          }
          
          // –û–Ω–æ–≤–ª—é—î–º–æ –∫–æ–Ω—Ç—É—Ä
          child.children.forEach(outline => {
            if (outline.userData.isOutline && outline.material && outline.material.color) {
              outline.material.color.copy(glowColor).multiplyScalar(1.2);
            }
          });
        }
      });
    }
  };
  [strengthEl, thresholdEl, radiusEl, exposureEl, glowEl, glowHueEl].forEach(el => el.addEventListener('input', sync));
  
  // –û–±—Ä–æ–±–Ω–∏–∫–∏ –ø–µ—Ä–µ–º–∏–∫–∞–Ω–Ω—è —Ä–µ–∂–∏–º—ñ–≤
  document.querySelectorAll('input[name="bloomMode"]').forEach(radio => {
    radio.addEventListener('change', (e) => {
      const mode = e.target.value;
      switchBloomMode(mode);
      
      if (mode === 'simple') {
        currentBloomPass = simpleBloom.bloomPass;
      } else {
        currentBloomPass = selectiveBloom.bloomPass;
        // –í–∏–º–∏–∫–∞—î–º–æ –ø—É–ª—å—Å–∞—Ü—ñ—è –≤ —Å–µ–ª–µ–∫—Ç–∏–≤–Ω–æ–º—É —Ä–µ–∂–∏–º—ñ
        if (pulseEnabled) togglePulse();
      }
      
      sync(); // –û–Ω–æ–≤–ª—é—î–º–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏
    });
  });
  
  // –û–±—Ä–æ–±–Ω–∏–∫ –∫–Ω–æ–ø–∫–∏ –ø—É–ª—å—Å–∞—Ü—ñ—ó
  document.getElementById('pulseToggle').addEventListener('click', togglePulse);
  
  sync();

  // ----- resize
  window.addEventListener('resize', () => {
    const w = container.clientWidth;
    const h = container.clientHeight;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
    
    // –û–Ω–æ–≤–ª—é—î–º–æ —Ä–æ–∑–º—ñ—Ä–∏ –¥–ª—è –æ–±–æ—Ö –∫–æ–º–ø–æ–∑–∏—Ç–æ—Ä—ñ–≤
    if (simpleComposer) simpleComposer.setSize(w, h);
    if (bloomComposer) bloomComposer.setSize(w, h);
    if (finalComposer) finalComposer.setSize(w, h);
  });

  // ----- –∞–Ω—ñ–º–∞—Ü—ñ—è
  const clock = new THREE.Clock();
  (function animate() {
    const dt = clock.getDelta();
    controls.update();
    
    // –û–Ω–æ–≤–ª—é—î–º–æ –ø—É–ª—å—Å–∞—Ü—ñ—é
    updatePulse(dt);
    
    // –†–µ–Ω–¥–µ—Ä–∏–º–æ –≤ –∑–∞–ª–µ–∂–Ω–æ—Å—Ç—ñ –≤—ñ–¥ —Ä–µ–∂–∏–º—É
    if (bloomMode === 'simple') {
      simpleComposer.render(dt);
    } else {
      renderBloom(true);
      finalPass.uniforms.bloomTexture.value = bloomComposer.renderTarget2.texture;
      finalComposer.render();
    }
    
    requestAnimationFrame(animate);
  })();
</script>
</body>
</html>